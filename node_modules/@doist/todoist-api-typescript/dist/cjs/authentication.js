"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuthStateParameter = getAuthStateParameter;
exports.getAuthorizationUrl = getAuthorizationUrl;
exports.getAuthToken = getAuthToken;
exports.revokeAuthToken = revokeAuthToken;
exports.revokeToken = revokeToken;
const rest_client_1 = require("./rest-client");
const uuid_1 = require("uuid");
const types_1 = require("./types");
const endpoints_1 = require("./consts/endpoints");
/**
 * Creates a Basic Authentication header value from client credentials.
 * @param clientId - The OAuth client ID
 * @param clientSecret - The OAuth client secret
 * @returns The Basic Auth header value (without the 'Basic ' prefix)
 */
function createBasicAuthHeader(clientId, clientSecret) {
    const credentials = `${clientId}:${clientSecret}`;
    return Buffer.from(credentials).toString('base64');
}
/**
 * Generates a random state parameter for OAuth2 authorization.
 * The state parameter helps prevent CSRF attacks.
 *
 * @example
 * ```typescript
 * const state = getAuthStateParameter()
 * // Store state in session
 * const authUrl = getAuthorizationUrl(clientId, ['data:read'], state)
 * ```
 *
 * @returns A random UUID v4 string
 */
function getAuthStateParameter() {
    return (0, uuid_1.v4)();
}
/**
 * Generates the authorization URL for the OAuth2 flow.
 *
 * @example
 * ```typescript
 * const url = getAuthorizationUrl(
 *   'your-client-id',
 *   ['data:read', 'task:add'],
 *   state
 * )
 * // Redirect user to url
 * ```
 *
 * @returns The full authorization URL to redirect users to
 * @see https://todoist.com/api/v1/docs#tag/Authorization/OAuth
 */
function getAuthorizationUrl({ clientId, permissions, state, baseUrl, }) {
    if (!(permissions === null || permissions === void 0 ? void 0 : permissions.length)) {
        throw new Error('At least one scope value should be passed for permissions.');
    }
    const scope = permissions.join(',');
    return `${(0, endpoints_1.getAuthBaseUri)(baseUrl)}${endpoints_1.ENDPOINT_AUTHORIZATION}?client_id=${clientId}&scope=${scope}&state=${state}`;
}
async function getAuthToken(args, baseUrlOrOptions) {
    var _a;
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    try {
        const response = await (0, rest_client_1.request)({
            httpMethod: 'POST',
            baseUri: (0, endpoints_1.getAuthBaseUri)(baseUrl),
            relativePath: endpoints_1.ENDPOINT_GET_TOKEN,
            apiToken: undefined,
            payload: args,
            customFetch,
        });
        if (response.status !== 200 || !((_a = response.data) === null || _a === void 0 ? void 0 : _a.accessToken)) {
            throw new types_1.TodoistRequestError('Authentication token exchange failed.', response.status, response.data);
        }
        return response.data;
    }
    catch (error) {
        // Re-throw with custom message for authentication failures
        const err = error;
        throw new types_1.TodoistRequestError('Authentication token exchange failed.', err.httpStatusCode, err.responseData);
    }
}
async function revokeAuthToken(args, baseUrlOrOptions) {
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    const response = await (0, rest_client_1.request)({
        httpMethod: 'POST',
        baseUri: (0, endpoints_1.getSyncBaseUri)(baseUrl),
        relativePath: endpoints_1.ENDPOINT_REVOKE_TOKEN,
        apiToken: undefined,
        payload: args,
        customFetch,
    });
    return (0, rest_client_1.isSuccess)(response);
}
async function revokeToken(args, baseUrlOrOptions) {
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    const { clientId, clientSecret, token } = args;
    // Create Basic Auth header as per RFC 7009
    const basicAuth = createBasicAuthHeader(clientId, clientSecret);
    const customHeaders = {
        Authorization: `Basic ${basicAuth}`,
    };
    // Request body only contains the token and optional token_type_hint
    const requestBody = {
        token,
        token_type_hint: 'access_token',
    };
    const response = await (0, rest_client_1.request)({
        httpMethod: 'POST',
        baseUri: (0, endpoints_1.getSyncBaseUri)(baseUrl),
        relativePath: endpoints_1.ENDPOINT_REVOKE,
        apiToken: undefined,
        payload: requestBody,
        requestId: undefined,
        hasSyncCommands: false,
        customHeaders: customHeaders,
        customFetch,
    });
    return (0, rest_client_1.isSuccess)(response);
}
