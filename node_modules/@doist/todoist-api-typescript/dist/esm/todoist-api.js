import { request, isSuccess } from './rest-client.js';
import { getSyncBaseUri, ENDPOINT_REST_TASKS, ENDPOINT_REST_TASKS_FILTER, ENDPOINT_REST_TASKS_COMPLETED_BY_COMPLETION_DATE, ENDPOINT_REST_TASKS_COMPLETED_BY_DUE_DATE, ENDPOINT_REST_TASKS_COMPLETED_SEARCH, ENDPOINT_REST_PROJECTS, ENDPOINT_REST_PROJECTS_SEARCH, ENDPOINT_SYNC_QUICK_ADD, ENDPOINT_REST_TASK_CLOSE, ENDPOINT_REST_TASK_REOPEN, ENDPOINT_REST_TASK_MOVE, ENDPOINT_REST_LABELS, ENDPOINT_REST_LABELS_SEARCH, ENDPOINT_REST_PROJECT_COLLABORATORS, ENDPOINT_REST_SECTIONS, ENDPOINT_REST_SECTIONS_SEARCH, ENDPOINT_REST_COMMENTS, ENDPOINT_REST_LABELS_SHARED, ENDPOINT_REST_LABELS_SHARED_RENAME, ENDPOINT_REST_LABELS_SHARED_REMOVE, ENDPOINT_SYNC, PROJECT_ARCHIVE, PROJECT_UNARCHIVE, ENDPOINT_REST_PROJECTS_MOVE_TO_WORKSPACE, ENDPOINT_REST_PROJECTS_MOVE_TO_PERSONAL, ENDPOINT_REST_PROJECTS_ARCHIVED, ENDPOINT_REST_USER, ENDPOINT_REST_PRODUCTIVITY, ENDPOINT_REST_ACTIVITIES, ENDPOINT_REST_UPLOADS, ENDPOINT_WORKSPACE_INVITATIONS, ENDPOINT_WORKSPACE_INVITATIONS_ALL, ENDPOINT_WORKSPACE_INVITATIONS_DELETE, getWorkspaceInvitationAcceptEndpoint, getWorkspaceInvitationRejectEndpoint, ENDPOINT_WORKSPACE_JOIN, ENDPOINT_WORKSPACE_LOGO, ENDPOINT_WORKSPACE_PLAN_DETAILS, ENDPOINT_WORKSPACE_USERS, getWorkspaceActiveProjectsEndpoint, getWorkspaceArchivedProjectsEndpoint, } from './consts/endpoints.js';
import { validateAttachment, validateComment, validateCommentArray, validateCurrentUser, validateLabel, validateLabelArray, validateProject, validateProjectArray, validateSection, validateSectionArray, validateTask, validateTaskArray, validateUserArray, validateProductivityStats, validateActivityEventArray, validateWorkspaceUserArray, validateWorkspaceInvitation, validateWorkspaceInvitationArray, validateWorkspacePlanDetails, validateJoinWorkspaceResult, validateWorkspaceArray, } from './utils/validators.js';
import { formatDateToYYYYMMDD } from './utils/url-helpers.js';
import { uploadMultipartFile } from './utils/multipart-upload.js';
import { normalizeObjectTypeForApi, denormalizeObjectTypeFromApi } from './utils/activity-helpers.js';
import { processTaskContent } from './utils/uncompletable-helpers.js';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { TodoistRequestError } from './types/index.js';
const MAX_COMMAND_COUNT = 100;
/**
 * Joins path segments using `/` separator.
 * @param segments A list of **valid** path segments.
 * @returns A joined path.
 */
function generatePath(...segments) {
    return segments.join('/');
}
export class TodoistApi {
    constructor(
    /**
     * Your Todoist API token.
     */
    authToken, 
    /**
     * Optional custom API base URL or options object
     */
    baseUrlOrOptions) {
        this.authToken = authToken;
        // Handle backward compatibility
        if (typeof baseUrlOrOptions === 'string') {
            // Legacy constructor: (authToken, baseUrl)
            // eslint-disable-next-line no-console
            console.warn('TodoistApi constructor with baseUrl as second parameter is deprecated. Use options object instead: new TodoistApi(token, { baseUrl, customFetch })');
            this.syncApiBase = getSyncBaseUri(baseUrlOrOptions);
            this.customFetch = undefined;
        }
        else {
            // New constructor: (authToken, options)
            const options = baseUrlOrOptions || {};
            this.syncApiBase = getSyncBaseUri(options.baseUrl);
            this.customFetch = options.customFetch;
        }
    }
    /**
     * Makes a request to the Sync API and handles error checking.
     *
     * @param syncRequest - The sync request payload
     * @param requestId - Optional request identifier
     * @param hasSyncCommands - Whether this request contains sync commands (write operations)
     * @returns The sync response data
     * @throws TodoistRequestError if sync status contains errors
     */
    async requestSync(syncRequest, requestId, hasSyncCommands = false) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_SYNC,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: syncRequest,
            requestId: requestId,
            hasSyncCommands: hasSyncCommands,
        });
        // Check for sync errors and throw if any are found
        if (response.data.syncStatus) {
            Object.entries(response.data.syncStatus).forEach(([_, value]) => {
                if (value === 'ok')
                    return;
                throw new TodoistRequestError(value.error, value.httpCode, value.errorExtra);
            });
        }
        return response.data;
    }
    /**
     * Retrieves information about the authenticated user.
     *
     * @returns A promise that resolves to the current user's information.
     */
    async getUser() {
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_USER,
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateCurrentUser(response.data);
    }
    /**
     * Retrieves a single active (non-completed) task by its ID.
     *
     * @param id - The unique identifier of the task.
     * @returns A promise that resolves to the requested task.
     */
    async getTask(id) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateTask(response.data);
    }
    /**
     * Retrieves a list of active tasks filtered by specific parameters.
     *
     * @param args - Filter parameters such as project ID, label ID, or due date.
     * @returns A promise that resolves to an array of tasks.
     */
    async getTasks(args = {}) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateTaskArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves tasks filtered by a filter string.
     *
     * @param args - Parameters for filtering tasks, including the query string and optional language.
     * @returns A promise that resolves to a paginated response of tasks.
     */
    async getTasksByFilter(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS_FILTER,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateTaskArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves completed tasks by completion date.
     *
     * @param args - Parameters for filtering, including required since, until.
     * @returns A promise that resolves to a paginated response of completed tasks.
     */
    async getCompletedTasksByCompletionDate(args) {
        const { data: { items, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS_COMPLETED_BY_COMPLETION_DATE,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            items: validateTaskArray(items),
            nextCursor,
        };
    }
    /**
     * Retrieves completed tasks by due date.
     *
     * @param args - Parameters for filtering, including required since, until.
     * @returns A promise that resolves to a paginated response of completed tasks.
     */
    async getCompletedTasksByDueDate(args) {
        const { data: { items, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS_COMPLETED_BY_DUE_DATE,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            items: validateTaskArray(items),
            nextCursor,
        };
    }
    /**
     * Searches completed tasks by query string.
     *
     * @param args - Parameters for searching, including the query string.
     * @returns A promise that resolves to a paginated response of completed tasks.
     */
    async searchCompletedTasks(args) {
        const { data: { items, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS_COMPLETED_SEARCH,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            items: validateTaskArray(items),
            nextCursor,
        };
    }
    /**
     * Creates a new task with the provided parameters.
     *
     * @param args - Task creation parameters such as content, due date, or priority.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the created task.
     */
    async addTask(args, requestId) {
        // Process content based on isUncompletable flag
        const processedArgs = Object.assign(Object.assign({}, args), { content: processTaskContent(args.content, args.isUncompletable) });
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_TASKS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: processedArgs,
            requestId: requestId,
        });
        return validateTask(response.data);
    }
    /**
     * Quickly adds a task using natural language processing for due dates.
     *
     * @param args - Quick add task parameters, including content and due date.
     * @returns A promise that resolves to the created task.
     */
    async quickAddTask(args) {
        // Process text based on isUncompletable flag
        const processedArgs = Object.assign(Object.assign({}, args), { text: processTaskContent(args.text, args.isUncompletable) });
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_SYNC_QUICK_ADD,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: processedArgs,
        });
        return validateTask(response.data);
    }
    /**
     * Updates an existing task by its ID with the provided parameters.
     *
     * @param id - The unique identifier of the task to update.
     * @param args - Update parameters such as content, priority, or due date.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated task.
     */
    async updateTask(id, args, requestId) {
        z.string().parse(id);
        // Process content if both content and isUncompletable are provided
        const processedArgs = args.content && args.isUncompletable !== undefined
            ? Object.assign(Object.assign({}, args), { content: processTaskContent(args.content, args.isUncompletable) }) : args;
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: processedArgs,
            requestId: requestId,
        });
        return validateTask(response.data);
    }
    /**
     * Moves existing tasks by their ID to either a different parent/section/project.
     *
     * @param ids - The unique identifier of the tasks to be moved.
     * @param args - The paramets that should contain only one of projectId, sectionId, or parentId
     * @param requestId - Optional custom identifier for the request.
     * @returns - A promise that resolves to an array of the updated tasks.
     * @deprecated Use `moveTask` for single task operations. This method uses the Sync API and may be removed in a future version.
     */
    async moveTasks(ids, args, requestId) {
        var _a;
        if (ids.length > MAX_COMMAND_COUNT) {
            throw new TodoistRequestError(`Maximum number of items is ${MAX_COMMAND_COUNT}`, 400);
        }
        const commands = ids.map((id) => ({
            type: 'item_move',
            uuid: uuidv4(),
            args: Object.assign(Object.assign(Object.assign({ id }, (args.projectId && { project_id: args.projectId })), (args.sectionId && { section_id: args.sectionId })), (args.parentId && { parent_id: args.parentId })),
        }));
        const syncRequest = {
            commands,
            resource_types: ['items'],
        };
        const syncResponse = await this.requestSync(syncRequest, requestId, true);
        if (!((_a = syncResponse.items) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new TodoistRequestError('Tasks not found', 404);
        }
        const syncTasks = syncResponse.items.filter((task) => ids.includes(task.id));
        if (!syncTasks.length) {
            throw new TodoistRequestError('Tasks not found', 404);
        }
        return validateTaskArray(syncTasks);
    }
    /**
     * Moves a task by its ID to either a different parent/section/project.
     *
     * @param id - The unique identifier of the task to be moved.
     * @param args - The parameters that should contain exactly one of projectId, sectionId, or parentId
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated task.
     */
    async moveTask(id, args, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id, ENDPOINT_REST_TASK_MOVE),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: Object.assign(Object.assign(Object.assign({}, (args.projectId && { project_id: args.projectId })), (args.sectionId && { section_id: args.sectionId })), (args.parentId && { parent_id: args.parentId })),
            requestId: requestId,
        });
        return validateTask(response.data);
    }
    /**
     * Closes (completes) a task by its ID.
     *
     * @param id - The unique identifier of the task to close.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async closeTask(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id, ENDPOINT_REST_TASK_CLOSE),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Reopens a previously closed (completed) task by its ID.
     *
     * @param id - The unique identifier of the task to reopen.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async reopenTask(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id, ENDPOINT_REST_TASK_REOPEN),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Deletes a task by its ID.
     *
     * @param id - The unique identifier of the task to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async deleteTask(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_TASKS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Retrieves a project by its ID.
     *
     * @param id - The unique identifier of the project.
     * @returns A promise that resolves to the requested project.
     */
    async getProject(id) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateProject(response.data);
    }
    /**
     * Retrieves all projects with optional filters.
     *
     * @param args - Optional filters for retrieving projects.
     * @returns A promise that resolves to an array of projects.
     */
    async getProjects(args = {}) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateProjectArray(results),
            nextCursor,
        };
    }
    /**
     * Searches projects by name.
     *
     * @param args - Search parameters including the query string.
     * @returns A promise that resolves to a paginated response of projects.
     */
    async searchProjects(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS_SEARCH,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateProjectArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves all archived projects with optional filters.
     *
     * @param args - Optional filters for retrieving archived projects.
     * @returns A promise that resolves to an array of archived projects.
     */
    async getArchivedProjects(args = {}) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS_ARCHIVED,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateProjectArray(results),
            nextCursor,
        };
    }
    /**
     * Creates a new project with the provided parameters.
     *
     * @param args - Project creation parameters such as name or color.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the created project.
     */
    async addProject(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateProject(response.data);
    }
    /**
     * Updates an existing project by its ID with the provided parameters.
     *
     * @param id - The unique identifier of the project to update.
     * @param args - Update parameters such as name or color.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated project.
     */
    async updateProject(id, args, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateProject(response.data);
    }
    /**
     * Deletes a project by its ID.
     *
     * @param id - The unique identifier of the project to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async deleteProject(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Archives a project by its ID.
     *
     * @param id - The unique identifier of the project to archive.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated project.
     */
    async archiveProject(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, id, PROJECT_ARCHIVE),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return validateProject(response.data);
    }
    /**
     * Unarchives a project by its ID.
     *
     * @param id - The unique identifier of the project to unarchive.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated project.
     */
    async unarchiveProject(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, id, PROJECT_UNARCHIVE),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return validateProject(response.data);
    }
    /**
     * Moves a project to a workspace.
     *
     * @param args - The arguments for moving the project.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the moved project.
     */
    async moveProjectToWorkspace(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS_MOVE_TO_WORKSPACE,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateProject(response.data.project);
    }
    /**
     * Moves a project to personal.
     *
     * @param args - The arguments for moving the project.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the moved project.
     */
    async moveProjectToPersonal(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PROJECTS_MOVE_TO_PERSONAL,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateProject(response.data.project);
    }
    /**
     * Retrieves a list of collaborators for a specific project.
     *
     * @param projectId - The unique identifier of the project.
     * @param args - Optional parameters to filter collaborators.
     * @returns A promise that resolves to an array of collaborators for the project.
     */
    async getProjectCollaborators(projectId, args = {}) {
        z.string().parse(projectId);
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_PROJECTS, projectId, ENDPOINT_REST_PROJECT_COLLABORATORS),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateUserArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves all sections within a specific project or matching criteria.
     *
     * @param args - Filter parameters such as project ID. If no projectId is provided,
     * all sections are returned.
     * @returns A promise that resolves to an array of sections.
     */
    async getSections(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_SECTIONS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateSectionArray(results),
            nextCursor,
        };
    }
    /**
     * Searches sections by name.
     *
     * @param args - Search parameters including the query string.
     * @returns A promise that resolves to a paginated response of sections.
     */
    async searchSections(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_SECTIONS_SEARCH,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateSectionArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves a single section by its ID.
     *
     * @param id - The unique identifier of the section.
     * @returns A promise that resolves to the requested section.
     */
    async getSection(id) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_SECTIONS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateSection(response.data);
    }
    /**
     * Creates a new section within a project.
     *
     * @param args - Section creation parameters such as name or project ID.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the created section.
     */
    async addSection(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_SECTIONS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateSection(response.data);
    }
    /**
     * Updates a section by its ID with the provided parameters.
     *
     * @param id - The unique identifier of the section to update.
     * @param args - Update parameters such as name or project ID.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated section.
     */
    async updateSection(id, args, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_SECTIONS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateSection(response.data);
    }
    /**
     * Deletes a section by its ID.
     *
     * @param id - The unique identifier of the section to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async deleteSection(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_SECTIONS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Retrieves a label by its ID.
     *
     * @param id - The unique identifier of the label.
     * @returns A promise that resolves to the requested label.
     */
    async getLabel(id) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_LABELS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateLabel(response.data);
    }
    /**
     * Retrieves all labels.
     *
     * @param args - Optional filter parameters.
     * @returns A promise that resolves to an array of labels.
     */
    async getLabels(args = {}) {
        const { data: { results, nextCursor: nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateLabelArray(results),
            nextCursor,
        };
    }
    /**
     * Searches labels by name.
     *
     * @param args - Search parameters including the query string.
     * @returns A promise that resolves to a paginated response of labels.
     */
    async searchLabels(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS_SEARCH,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateLabelArray(results),
            nextCursor,
        };
    }
    /**
     * Adds a new label.
     *
     * @param args - Label creation parameters such as name.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the created label.
     */
    async addLabel(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateLabel(response.data);
    }
    /**
     * Updates an existing label by its ID.
     *
     * @param id - The unique identifier of the label to update.
     * @param args - Update parameters such as name or color.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated label.
     */
    async updateLabel(id, args, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_LABELS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateLabel(response.data);
    }
    /**
     * Deletes a label by its ID.
     *
     * @param id - The unique identifier of the label to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async deleteLabel(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_LABELS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Retrieves a list of shared labels.
     *
     * @param args - Optional parameters to filter shared labels.
     * @returns A promise that resolves to an array of shared labels.
     */
    async getSharedLabels(args) {
        const { data: { results, nextCursor: nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS_SHARED,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return { results, nextCursor };
    }
    /**
     * Renames an existing shared label.
     *
     * @param args - Parameters for renaming the shared label, including the current and new name.
     * @returns A promise that resolves to `true` if successful.
     */
    async renameSharedLabel(args) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS_SHARED_RENAME,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return isSuccess(response);
    }
    /**
     * Removes a shared label.
     *
     * @param args - Parameters for removing the shared label.
     * @returns A promise that resolves to `true` if successful.
     */
    async removeSharedLabel(args) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_LABELS_SHARED_REMOVE,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return isSuccess(response);
    }
    /**
     * Retrieves all comments associated with a task or project.
     *
     * @param args - Parameters for retrieving comments, such as task ID or project ID.
     * @returns A promise that resolves to an array of comments.
     */
    async getComments(args) {
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_COMMENTS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
        });
        return {
            results: validateCommentArray(results),
            nextCursor,
        };
    }
    /**
     * Retrieves a specific comment by its ID.
     *
     * @param id - The unique identifier of the comment to retrieve.
     * @returns A promise that resolves to the requested comment.
     */
    async getComment(id) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_COMMENTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateComment(response.data);
    }
    /**
     * Adds a comment to a task or project.
     *
     * @param args - Parameters for creating the comment, such as content and the target task or project ID.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the created comment.
     */
    async addComment(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_COMMENTS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateComment(response.data);
    }
    /**
     * Updates an existing comment by its ID.
     *
     * @param id - The unique identifier of the comment to update.
     * @param args - Update parameters such as new content.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the updated comment.
     */
    async updateComment(id, args, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_COMMENTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return validateComment(response.data);
    }
    /**
     * Deletes a comment by its ID.
     *
     * @param id - The unique identifier of the comment to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if successful.
     */
    async deleteComment(id, requestId) {
        z.string().parse(id);
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: generatePath(ENDPOINT_REST_COMMENTS, id),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /**
     * Retrieves productivity stats for the authenticated user.
     *
     * @returns A promise that resolves to the productivity stats.
     */
    async getProductivityStats() {
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_PRODUCTIVITY,
            apiToken: this.authToken,
            customFetch: this.customFetch,
        });
        return validateProductivityStats(response.data);
    }
    /**
     * Retrieves activity logs with optional filters.
     *
     * @param args - Optional filter parameters for activity logs.
     * @returns A promise that resolves to a paginated response of activity events.
     */
    async getActivityLogs(args = {}) {
        // Convert Date objects to YYYY-MM-DD strings and modern object types to legacy API types
        const processedArgs = Object.assign(Object.assign(Object.assign(Object.assign({}, args), (args.since instanceof Date && { since: formatDateToYYYYMMDD(args.since) })), (args.until instanceof Date && { until: formatDateToYYYYMMDD(args.until) })), (args.objectType && { objectType: normalizeObjectTypeForApi(args.objectType) }));
        const { data: { results, nextCursor }, } = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_ACTIVITIES,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: processedArgs,
        });
        // Convert legacy API object types back to modern SDK types
        const normalizedResults = results.map((event) => {
            const normalizedType = denormalizeObjectTypeFromApi(event.objectType);
            return Object.assign(Object.assign({}, event), { objectType: normalizedType || event.objectType });
        });
        return {
            results: validateActivityEventArray(normalizedResults),
            nextCursor,
        };
    }
    /**
     * Uploads a file and returns attachment metadata.
     * This creates an upload record that can be referenced in tasks or comments.
     *
     * @param args - Upload parameters including file content, filename, and optional project ID.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to the uploaded file's attachment metadata.
     *
     * @example
     * ```typescript
     * // Upload from a file path
     * const upload = await api.uploadFile({
     *   file: '/path/to/document.pdf',
     *   projectId: '12345'
     * })
     *
     * // Upload from a Buffer
     * const buffer = fs.readFileSync('/path/to/document.pdf')
     * const upload = await api.uploadFile({
     *   file: buffer,
     *   fileName: 'document.pdf',  // Required for Buffer/Stream
     *   projectId: '12345'
     * })
     *
     * // Use the returned fileUrl in a comment
     * await api.addComment({
     *   content: 'See attached document',
     *   taskId: '67890',
     *   attachment: {
     *     fileUrl: upload.fileUrl,
     *     fileName: upload.fileName,
     *     fileType: upload.fileType,
     *     resourceType: upload.resourceType
     *   }
     * })
     * ```
     */
    async uploadFile(args, requestId) {
        const additionalFields = {};
        if (args.projectId) {
            additionalFields.project_id = args.projectId;
        }
        const data = await uploadMultipartFile({
            baseUrl: this.syncApiBase,
            authToken: this.authToken,
            endpoint: ENDPOINT_REST_UPLOADS,
            file: args.file,
            fileName: args.fileName,
            additionalFields: additionalFields,
            requestId: requestId,
            customFetch: this.customFetch,
        });
        return validateAttachment(data);
    }
    /**
     * Deletes an uploaded file by its URL.
     *
     * @param args - The file URL to delete.
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to `true` if deletion was successful.
     *
     * @example
     * ```typescript
     * await api.deleteUpload({
     *   fileUrl: 'https://cdn.todoist.com/...'
     * })
     * ```
     */
    async deleteUpload(args, requestId) {
        const response = await request({
            httpMethod: 'DELETE',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_REST_UPLOADS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: args,
            requestId: requestId,
        });
        return isSuccess(response);
    }
    /* Workspace methods */
    /**
     * Gets pending invitations for a workspace.
     *
     * @param args - Arguments including workspace ID.
     * @param requestId - Optional request ID for idempotency.
     * @returns Array of email addresses with pending invitations.
     */
    async getWorkspaceInvitations(args, requestId) {
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_INVITATIONS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: { workspace_id: args.workspaceId },
            requestId: requestId,
        });
        return response.data;
    }
    /**
     * Gets all workspace invitations (admin only).
     *
     * @param requestId - Optional request ID for idempotency.
     * @returns Array of email addresses with pending invitations.
     */
    async getAllWorkspaceInvitations(args = {}, requestId) {
        const queryParams = {};
        if (args.workspaceId) {
            queryParams.workspace_id = args.workspaceId;
        }
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_INVITATIONS_ALL,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: queryParams,
            requestId: requestId,
        });
        return validateWorkspaceInvitationArray(response.data);
    }
    /**
     * Deletes a workspace invitation (admin only).
     *
     * @param args - Arguments including workspace ID and user email.
     * @param requestId - Optional request ID for idempotency.
     * @returns The deleted invitation.
     */
    async deleteWorkspaceInvitation(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_INVITATIONS_DELETE,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: {
                workspace_id: args.workspaceId,
                user_email: args.userEmail,
            },
            requestId: requestId,
        });
        return validateWorkspaceInvitation(response.data);
    }
    /**
     * Accepts a workspace invitation.
     *
     * @param args - Arguments including invite code.
     * @param requestId - Optional request ID for idempotency.
     * @returns The accepted invitation.
     */
    async acceptWorkspaceInvitation(args, requestId) {
        const response = await request({
            httpMethod: 'PUT',
            baseUri: this.syncApiBase,
            relativePath: getWorkspaceInvitationAcceptEndpoint(args.inviteCode),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return validateWorkspaceInvitation(response.data);
    }
    /**
     * Rejects a workspace invitation.
     *
     * @param args - Arguments including invite code.
     * @param requestId - Optional request ID for idempotency.
     * @returns The rejected invitation.
     */
    async rejectWorkspaceInvitation(args, requestId) {
        const response = await request({
            httpMethod: 'PUT',
            baseUri: this.syncApiBase,
            relativePath: getWorkspaceInvitationRejectEndpoint(args.inviteCode),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            requestId: requestId,
        });
        return validateWorkspaceInvitation(response.data);
    }
    /**
     * Joins a workspace via invitation link or domain auto-join.
     *
     * @param args - Arguments including invite code or workspace ID.
     * @param requestId - Optional request ID for idempotency.
     * @returns Workspace user information.
     */
    async joinWorkspace(args, requestId) {
        const response = await request({
            httpMethod: 'POST',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_JOIN,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: {
                invite_code: args.inviteCode,
                workspace_id: args.workspaceId,
            },
            requestId: requestId,
        });
        return validateJoinWorkspaceResult(response.data);
    }
    /**
     * Uploads or updates a workspace logo.
     *
     * @param args - Arguments including workspace ID, file, and options.
     * @param requestId - Optional request ID for idempotency.
     * @returns Logo information or null if deleted.
     */
    async uploadWorkspaceLogo(args, requestId) {
        if (args.delete) {
            // Delete logo
            const data = await uploadMultipartFile({
                baseUrl: this.syncApiBase,
                authToken: this.authToken,
                endpoint: ENDPOINT_WORKSPACE_LOGO,
                file: Buffer.alloc(0), // Empty buffer for delete
                fileName: 'delete',
                additionalFields: {
                    workspace_id: args.workspaceId,
                    delete: true,
                },
                requestId: requestId,
                customFetch: this.customFetch,
            });
            return data;
        }
        if (!args.file) {
            throw new Error('file is required when not deleting logo');
        }
        // Validate buffer is not empty if it's a Buffer
        if (Buffer.isBuffer(args.file) && args.file.length === 0) {
            throw new Error('Cannot upload empty image file');
        }
        const additionalFields = {
            workspace_id: args.workspaceId,
        };
        const data = await uploadMultipartFile({
            baseUrl: this.syncApiBase,
            authToken: this.authToken,
            endpoint: ENDPOINT_WORKSPACE_LOGO,
            file: args.file,
            fileName: args.fileName,
            additionalFields: additionalFields,
            requestId: requestId,
            customFetch: this.customFetch,
        });
        return data;
    }
    /**
     * Gets workspace plan and billing details.
     *
     * @param args - Arguments including workspace ID.
     * @param requestId - Optional request ID for idempotency.
     * @returns Workspace plan details.
     */
    async getWorkspacePlanDetails(args, requestId) {
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_PLAN_DETAILS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: { workspace_id: args.workspaceId },
            requestId: requestId,
        });
        return validateWorkspacePlanDetails(response.data);
    }
    /**
     * Gets workspace users with pagination.
     *
     * @param args - Arguments including optional workspace ID, cursor, and limit.
     * @param requestId - Optional request ID for idempotency.
     * @returns Paginated list of workspace users.
     */
    async getWorkspaceUsers(args = {}, requestId) {
        const queryParams = {};
        if (args.workspaceId !== undefined && args.workspaceId !== null) {
            queryParams.workspace_id = args.workspaceId;
        }
        if (args.cursor) {
            queryParams.cursor = args.cursor;
        }
        if (args.limit) {
            queryParams.limit = args.limit;
        }
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: ENDPOINT_WORKSPACE_USERS,
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: queryParams,
            requestId: requestId,
        });
        return {
            hasMore: response.data.hasMore || false,
            nextCursor: response.data.nextCursor,
            workspaceUsers: validateWorkspaceUserArray(response.data.workspaceUsers || []),
        };
    }
    /**
     * Retrieves all workspaces for the authenticated user.
     *
     * Uses the Sync API internally to fetch workspace data.
     *
     * @param requestId - Optional custom identifier for the request.
     * @returns A promise that resolves to an array of workspaces.
     *
     * @example
     * ```typescript
     * const workspaces = await api.getWorkspaces()
     * workspaces.forEach(workspace => {
     *   console.log(`${workspace.name} (${workspace.plan}) - Role: ${workspace.role}`)
     * })
     * ```
     */
    async getWorkspaces(requestId) {
        const syncRequest = {
            sync_token: '*',
            resource_types: ['workspaces'],
        };
        const syncResponse = await this.requestSync(syncRequest, requestId, false);
        const workspacesData = syncResponse.workspaces;
        if (!workspacesData || typeof workspacesData !== 'object') {
            return [];
        }
        const workspacesArray = Object.values(workspacesData);
        return validateWorkspaceArray(workspacesArray);
    }
    /**
     * Gets active projects in a workspace with pagination.
     *
     * @param args - Arguments including workspace ID, cursor, and limit.
     * @param requestId - Optional request ID for idempotency.
     * @returns Paginated list of active workspace projects.
     */
    async getWorkspaceActiveProjects(args, requestId) {
        var _a;
        const queryParams = {};
        if (args.cursor) {
            queryParams.cursor = args.cursor;
        }
        if (args.limit) {
            queryParams.limit = args.limit;
        }
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: getWorkspaceActiveProjectsEndpoint(args.workspaceId),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: queryParams,
            requestId: requestId,
        });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
        const validatedProjects = (_a = response.data.results) === null || _a === void 0 ? void 0 : _a.map((project) => validateProject(project));
        return Object.assign(Object.assign({}, response.data), { 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            results: validatedProjects || [] });
    }
    /**
     * Gets archived projects in a workspace with pagination.
     *
     * @param args - Arguments including workspace ID, cursor, and limit.
     * @param requestId - Optional request ID for idempotency.
     * @returns Paginated list of archived workspace projects.
     */
    async getWorkspaceArchivedProjects(args, requestId) {
        var _a;
        const queryParams = {};
        if (args.cursor) {
            queryParams.cursor = args.cursor;
        }
        if (args.limit) {
            queryParams.limit = args.limit;
        }
        const response = await request({
            httpMethod: 'GET',
            baseUri: this.syncApiBase,
            relativePath: getWorkspaceArchivedProjectsEndpoint(args.workspaceId),
            apiToken: this.authToken,
            customFetch: this.customFetch,
            payload: queryParams,
            requestId: requestId,
        });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
        const validatedProjects = (_a = response.data.results) === null || _a === void 0 ? void 0 : _a.map((project) => validateProject(project));
        return Object.assign(Object.assign({}, response.data), { 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            results: validatedProjects || [] });
    }
}
