var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { isNetworkError } from '../types/http.js';
/**
 * Default retry configuration matching the original axios-retry behavior
 */
const DEFAULT_RETRY_CONFIG = {
    retries: 3,
    retryCondition: isNetworkError,
    retryDelay: (retryNumber) => {
        // First retry: immediate (0ms delay)
        // Subsequent retries: 500ms delay
        return retryNumber === 1 ? 0 : 500;
    },
};
/**
 * Cached HTTP agent to prevent creating multiple agents
 * null = not initialized, undefined = browser env, UndiciAgent = Node.js env
 */
let httpAgent = null;
/**
 * Gets the HTTP agent for Node.js environments or undefined for browser environments.
 * Uses dynamic import to avoid loading undici in browser environments.
 */
async function getHttpAgent() {
    var _a;
    if (httpAgent === null) {
        if (typeof process !== 'undefined' && ((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node)) {
            // We're in Node.js - dynamically import undici
            const { Agent } = await import('undici');
            httpAgent = new Agent({
                keepAliveTimeout: 1, // Close connections after 1ms of idle time
                keepAliveMaxTimeout: 1, // Maximum time to keep connections alive
            });
        }
        else {
            // We're in browser - no agent needed
            httpAgent = undefined;
        }
    }
    return httpAgent;
}
/**
 * Converts Headers object to a plain object
 */
function headersToObject(headers) {
    const result = {};
    headers.forEach((value, key) => {
        result[key] = value;
    });
    return result;
}
/**
 * Creates an AbortSignal that aborts after timeoutMs. Returns the signal and a
 * clear function to cancel the timeout early.
 */
function createTimeoutSignal(timeoutMs, existingSignal) {
    const controller = new AbortController();
    // Timeout logic
    const timeoutId = setTimeout(() => {
        controller.abort(new Error(`Request timeout after ${timeoutMs}ms`));
    }, timeoutMs);
    function clear() {
        clearTimeout(timeoutId);
    }
    // If there's an existing signal, forward its abort
    if (existingSignal) {
        if (existingSignal.aborted) {
            clearTimeout(timeoutId);
            controller.abort(existingSignal.reason);
        }
        else {
            existingSignal.addEventListener('abort', () => {
                clearTimeout(timeoutId);
                controller.abort(existingSignal.reason);
            }, { once: true });
        }
    }
    // Clean up timeout when request completes
    controller.signal.addEventListener('abort', () => {
        clearTimeout(timeoutId);
    });
    return { signal: controller.signal, clear };
}
/**
 * Converts native fetch Response to CustomFetchResponse for consistency
 */
function convertResponseToCustomFetch(response) {
    // Clone the response so we can read it multiple times (if clone method exists)
    const clonedResponse = response.clone ? response.clone() : response;
    return {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: headersToObject(response.headers),
        text: () => clonedResponse.text(),
        json: () => response.json(),
    };
}
/**
 * Performs a fetch request with retry logic and timeout support
 */
export async function fetchWithRetry(args) {
    const { url, options = {}, retryConfig = {}, customFetch } = args;
    const config = Object.assign(Object.assign({}, DEFAULT_RETRY_CONFIG), retryConfig);
    const { timeout, signal: userSignal } = options, fetchOptions = __rest(options, ["timeout", "signal"]);
    let lastError;
    for (let attempt = 0; attempt <= config.retries; attempt++) {
        // Timeout clear function for this attempt (hoisted for catch scope)
        let clearTimeoutFn;
        try {
            // Set up timeout and signal handling
            let requestSignal = userSignal || undefined;
            if (timeout && timeout > 0) {
                const timeoutResult = createTimeoutSignal(timeout, requestSignal);
                requestSignal = timeoutResult.signal;
                clearTimeoutFn = timeoutResult.clear;
            }
            // Use custom fetch or native fetch
            let fetchResponse;
            if (customFetch) {
                fetchResponse = await customFetch(url, Object.assign(Object.assign({}, fetchOptions), { signal: requestSignal, timeout }));
            }
            else {
                const nativeResponse = await fetch(url, Object.assign(Object.assign({}, fetchOptions), { signal: requestSignal, 
                    // @ts-expect-error - dispatcher is a valid option for Node.js fetch but not in the TS types
                    dispatcher: await getHttpAgent() }));
                fetchResponse = convertResponseToCustomFetch(nativeResponse);
            }
            // Check if the response is successful
            if (!fetchResponse.ok) {
                const errorMessage = `HTTP ${fetchResponse.status}: ${fetchResponse.statusText}`;
                const error = new Error(errorMessage);
                error.status = fetchResponse.status;
                error.statusText = fetchResponse.statusText;
                error.response = {
                    data: undefined, // Will be set below if we can parse the response
                    status: fetchResponse.status,
                    statusText: fetchResponse.statusText,
                    headers: fetchResponse.headers,
                };
                // Try to get response body for error details
                try {
                    const responseText = await fetchResponse.text();
                    let responseData;
                    try {
                        responseData = responseText ? JSON.parse(responseText) : undefined;
                    }
                    catch (_a) {
                        responseData = responseText;
                    }
                    error.data = responseData;
                    error.response.data = responseData;
                }
                catch (_b) {
                    // If we can't read the response body, that's OK
                }
                throw error;
            }
            // Parse response
            const responseText = await fetchResponse.text();
            let data;
            try {
                data = responseText ? JSON.parse(responseText) : undefined;
            }
            catch (_c) {
                // If JSON parsing fails, return the raw text
                data = responseText;
            }
            // Success – clear pending timeout (if any) so Node can exit promptly
            if (clearTimeoutFn) {
                clearTimeoutFn();
            }
            return {
                data,
                status: fetchResponse.status,
                statusText: fetchResponse.statusText,
                headers: fetchResponse.headers,
            };
        }
        catch (error) {
            lastError = error;
            // Check if this error should trigger a retry
            const shouldRetry = attempt < config.retries && config.retryCondition(lastError);
            if (!shouldRetry) {
                // Add network error flag for network errors
                if (isNetworkError(lastError)) {
                    const networkError = lastError;
                    networkError.isNetworkError = true;
                }
                if (clearTimeoutFn) {
                    clearTimeoutFn();
                }
                throw lastError;
            }
            // Wait before retrying
            const delay = config.retryDelay(attempt + 1);
            if (delay > 0) {
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            // Retry path – ensure this attempt's timeout is cleared before looping
            if (clearTimeoutFn) {
                clearTimeoutFn();
            }
        }
    }
    // This should never be reached, but just in case
    throw lastError || new Error('Request failed after retries');
}
