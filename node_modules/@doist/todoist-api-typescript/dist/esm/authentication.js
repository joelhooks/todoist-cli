import { request, isSuccess } from './rest-client.js';
import { v4 as uuid } from 'uuid';
import { TodoistRequestError } from './types/index.js';
import { getAuthBaseUri, getSyncBaseUri, ENDPOINT_AUTHORIZATION, ENDPOINT_GET_TOKEN, ENDPOINT_REVOKE_TOKEN, ENDPOINT_REVOKE, } from './consts/endpoints.js';
/**
 * Creates a Basic Authentication header value from client credentials.
 * @param clientId - The OAuth client ID
 * @param clientSecret - The OAuth client secret
 * @returns The Basic Auth header value (without the 'Basic ' prefix)
 */
function createBasicAuthHeader(clientId, clientSecret) {
    const credentials = `${clientId}:${clientSecret}`;
    return Buffer.from(credentials).toString('base64');
}
/**
 * Generates a random state parameter for OAuth2 authorization.
 * The state parameter helps prevent CSRF attacks.
 *
 * @example
 * ```typescript
 * const state = getAuthStateParameter()
 * // Store state in session
 * const authUrl = getAuthorizationUrl(clientId, ['data:read'], state)
 * ```
 *
 * @returns A random UUID v4 string
 */
export function getAuthStateParameter() {
    return uuid();
}
/**
 * Generates the authorization URL for the OAuth2 flow.
 *
 * @example
 * ```typescript
 * const url = getAuthorizationUrl(
 *   'your-client-id',
 *   ['data:read', 'task:add'],
 *   state
 * )
 * // Redirect user to url
 * ```
 *
 * @returns The full authorization URL to redirect users to
 * @see https://todoist.com/api/v1/docs#tag/Authorization/OAuth
 */
export function getAuthorizationUrl({ clientId, permissions, state, baseUrl, }) {
    if (!(permissions === null || permissions === void 0 ? void 0 : permissions.length)) {
        throw new Error('At least one scope value should be passed for permissions.');
    }
    const scope = permissions.join(',');
    return `${getAuthBaseUri(baseUrl)}${ENDPOINT_AUTHORIZATION}?client_id=${clientId}&scope=${scope}&state=${state}`;
}
export async function getAuthToken(args, baseUrlOrOptions) {
    var _a;
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    try {
        const response = await request({
            httpMethod: 'POST',
            baseUri: getAuthBaseUri(baseUrl),
            relativePath: ENDPOINT_GET_TOKEN,
            apiToken: undefined,
            payload: args,
            customFetch,
        });
        if (response.status !== 200 || !((_a = response.data) === null || _a === void 0 ? void 0 : _a.accessToken)) {
            throw new TodoistRequestError('Authentication token exchange failed.', response.status, response.data);
        }
        return response.data;
    }
    catch (error) {
        // Re-throw with custom message for authentication failures
        const err = error;
        throw new TodoistRequestError('Authentication token exchange failed.', err.httpStatusCode, err.responseData);
    }
}
export async function revokeAuthToken(args, baseUrlOrOptions) {
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    const response = await request({
        httpMethod: 'POST',
        baseUri: getSyncBaseUri(baseUrl),
        relativePath: ENDPOINT_REVOKE_TOKEN,
        apiToken: undefined,
        payload: args,
        customFetch,
    });
    return isSuccess(response);
}
export async function revokeToken(args, baseUrlOrOptions) {
    let baseUrl;
    let customFetch;
    if (typeof baseUrlOrOptions === 'string') {
        // Legacy signature: (args, baseUrl)
        baseUrl = baseUrlOrOptions;
        customFetch = undefined;
    }
    else if (baseUrlOrOptions) {
        // New signature: (args, options)
        baseUrl = baseUrlOrOptions.baseUrl;
        customFetch = baseUrlOrOptions.customFetch;
    }
    const { clientId, clientSecret, token } = args;
    // Create Basic Auth header as per RFC 7009
    const basicAuth = createBasicAuthHeader(clientId, clientSecret);
    const customHeaders = {
        Authorization: `Basic ${basicAuth}`,
    };
    // Request body only contains the token and optional token_type_hint
    const requestBody = {
        token,
        token_type_hint: 'access_token',
    };
    const response = await request({
        httpMethod: 'POST',
        baseUri: getSyncBaseUri(baseUrl),
        relativePath: ENDPOINT_REVOKE,
        apiToken: undefined,
        payload: requestBody,
        requestId: undefined,
        hasSyncCommands: false,
        customHeaders: customHeaders,
        customFetch,
    });
    return isSuccess(response);
}
