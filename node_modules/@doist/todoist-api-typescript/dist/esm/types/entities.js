var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { z } from 'zod';
import { getProjectUrl, getTaskUrl, getSectionUrl } from '../utils/url-helpers.js';
import { hasUncompletablePrefix } from '../utils/uncompletable-helpers.js';
export const DueDateSchema = z
    .object({
    isRecurring: z.boolean(),
    string: z.string(),
    date: z.string(),
})
    .extend({
    datetime: z.string().nullable().optional(),
    timezone: z.string().nullable().optional(),
    lang: z.string().nullable().optional(),
});
export const DurationSchema = z.object({
    amount: z.number().positive('Value should be greater than zero'),
    unit: z.enum(['minute', 'day']),
});
export const DeadlineSchema = z.object({
    date: z.string(),
    lang: z.string(),
});
export const TaskSchema = z
    .object({
    id: z.string(),
    userId: z.string(),
    projectId: z.string(),
    sectionId: z.string().nullable(),
    parentId: z.string().nullable(),
    addedByUid: z.string().nullable(),
    assignedByUid: z.string().nullable(),
    responsibleUid: z.string().nullable(),
    labels: z.array(z.string()),
    deadline: DeadlineSchema.nullable(),
    duration: DurationSchema.nullable(),
    checked: z.boolean(),
    isDeleted: z.boolean(),
    addedAt: z.string().nullable(),
    completedAt: z.string().nullable(),
    updatedAt: z.string().nullable(),
    due: DueDateSchema.nullable(),
    priority: z.number().int(),
    childOrder: z.number().int(),
    content: z.string(),
    description: z.string(),
    /**
     * @deprecated This field is deprecated and will always return 0. It will be removed in a future version. Do not use or rely on this field.
     */
    noteCount: z.number().int(),
    dayOrder: z.number().int(),
    isCollapsed: z.boolean(),
    isUncompletable: z.boolean().default(false),
})
    .transform((data) => {
    // Auto-detect uncompletable status from content prefix
    const isUncompletable = hasUncompletablePrefix(data.content);
    return Object.assign(Object.assign({}, data), { isUncompletable, url: getTaskUrl(data.id, data.content) });
});
/**
 * Base schema for all project types in Todoist.
 * Contains common fields shared between personal and workspace projects.
 */
export const BaseProjectSchema = z.object({
    id: z.string(),
    canAssignTasks: z.boolean(),
    childOrder: z.number().int(),
    color: z.string(),
    createdAt: z.string().nullable(),
    isArchived: z.boolean(),
    isDeleted: z.boolean(),
    isFavorite: z.boolean(),
    isFrozen: z.boolean(),
    name: z.string(),
    updatedAt: z.string().nullable(),
    viewStyle: z.string(),
    defaultOrder: z.number().int(),
    description: z.string(),
    isCollapsed: z.boolean(),
    isShared: z.boolean(),
});
/**
 * Schema for personal projects in Todoist.
 */
export const PersonalProjectSchema = BaseProjectSchema.extend({
    parentId: z.string().nullable(),
    inboxProject: z.boolean().optional().default(false),
}).transform((data) => {
    return Object.assign(Object.assign({}, data), { url: getProjectUrl(data.id, data.name) });
});
export const ProjectVisibilitySchema = z.enum(['restricted', 'team', 'public']);
/**
 * Schema for workspace projects in Todoist.
 */
export const WorkspaceProjectSchema = BaseProjectSchema.extend({
    access: z.object({ visibility: ProjectVisibilitySchema }).optional(),
    collaboratorRoleDefault: z.string(),
    folderId: z.string().nullable(),
    isInviteOnly: z.boolean().nullable(),
    isLinkSharingEnabled: z.boolean(),
    role: z.string().nullable(),
    status: z.string(),
    workspaceId: z.string(),
}).transform((data) => {
    return Object.assign(Object.assign({}, data), { url: getProjectUrl(data.id, data.name) });
});
export const SectionSchema = z
    .object({
    id: z.string(),
    userId: z.string(),
    projectId: z.string(),
    addedAt: z.string(),
    updatedAt: z.string(),
    archivedAt: z.string().nullable(),
    name: z.string(),
    sectionOrder: z.number().int(),
    isArchived: z.boolean(),
    isDeleted: z.boolean(),
    isCollapsed: z.boolean(),
})
    .transform((data) => {
    return Object.assign(Object.assign({}, data), { url: getSectionUrl(data.id, data.name) });
});
export const LabelSchema = z.object({
    id: z.string(),
    order: z.number().int().nullable(),
    name: z.string(),
    color: z.string(),
    isFavorite: z.boolean(),
});
export const AttachmentSchema = z
    .object({
    resourceType: z.string(),
})
    .extend({
    fileName: z.string().nullable().optional(),
    fileSize: z.number().int().nullable().optional(),
    fileType: z.string().nullable().optional(),
    fileUrl: z.string().nullable().optional(),
    fileDuration: z.number().int().nullable().optional(),
    uploadState: z.enum(['pending', 'completed']).nullable().optional(),
    image: z.string().nullable().optional(),
    imageWidth: z.number().int().nullable().optional(),
    imageHeight: z.number().int().nullable().optional(),
    url: z.string().nullable().optional(),
    title: z.string().nullable().optional(),
});
export const RawCommentSchema = z
    .object({
    id: z.string(),
    itemId: z.string().optional(),
    projectId: z.string().optional(),
    content: z.string(),
    postedAt: z.string(),
    fileAttachment: AttachmentSchema.nullable(),
    postedUid: z.string(),
    uidsToNotify: z.array(z.string()).nullable(),
    reactions: z.record(z.string(), z.array(z.string())).nullable(),
    isDeleted: z.boolean(),
})
    .refine((data) => {
    // At least one of itemId or projectId must be present
    return ((data.itemId !== undefined && data.projectId === undefined) ||
        (data.itemId === undefined && data.projectId !== undefined));
}, {
    message: 'Exactly one of itemId or projectId must be provided',
});
export const CommentSchema = RawCommentSchema.transform((data) => {
    const { itemId } = data, rest = __rest(data, ["itemId"]);
    return Object.assign(Object.assign({}, rest), { 
        // Map itemId to taskId for backwards compatibility
        taskId: itemId });
});
export const UserSchema = z.object({
    id: z.string(),
    name: z.string(),
    email: z.string(),
});
export const TimezoneInfoSchema = z.object({
    gmtString: z.string(),
    hours: z.number().int(),
    isDst: z.number().int(),
    minutes: z.number().int(),
    timezone: z.string(),
});
export const CurrentUserSchema = z.object({
    id: z.string(),
    email: z.string(),
    fullName: z.string(),
    avatarBig: z.string().nullish(),
    avatarMedium: z.string().nullish(),
    avatarS640: z.string().nullish(),
    avatarSmall: z.string().nullish(),
    businessAccountId: z.string().nullable(),
    isPremium: z.boolean(),
    premiumStatus: z.enum([
        'not_premium',
        'current_personal_plan',
        'legacy_personal_plan',
        'teams_business_member',
    ]),
    dateFormat: z.number().int(),
    timeFormat: z.number().int(),
    weeklyGoal: z.number().int(),
    dailyGoal: z.number().int(),
    completedCount: z.number().int(),
    completedToday: z.number().int(),
    karma: z.number(),
    karmaTrend: z.string(),
    lang: z.string(),
    nextWeek: z.number().int(),
    startDay: z.number().int(),
    startPage: z.string(),
    tzInfo: TimezoneInfoSchema,
    inboxProjectId: z.string(),
    daysOff: z.array(z.number().int()),
    weekendStartDay: z.number().int(),
});
const StreakSchema = z.object({
    count: z.number(),
    start: z.string(),
    end: z.string(),
});
const CompletedItemSchema = z.object({
    id: z.string(),
    completed: z.number(),
});
const ItemsWithDateSchema = z.object({
    items: z.array(CompletedItemSchema),
    totalCompleted: z.number(),
});
const KarmaUpdateSchema = z.object({
    time: z.string(),
    newKarma: z.number(),
    positiveKarma: z.number(),
    negativeKarma: z.number(),
    positiveKarmaReasons: z.array(z.any()),
    negativeKarmaReasons: z.array(z.any()),
});
export const ProductivityStatsSchema = z.object({
    completedCount: z.number(),
    daysItems: z.array(ItemsWithDateSchema.extend({
        date: z.string(),
    })),
    goals: z.object({
        currentDailyStreak: StreakSchema,
        currentWeeklyStreak: StreakSchema,
        dailyGoal: z.number(),
        ignoreDays: z.array(z.number()),
        karmaDisabled: z.number(),
        lastDailyStreak: StreakSchema,
        lastWeeklyStreak: StreakSchema,
        maxDailyStreak: StreakSchema,
        maxWeeklyStreak: StreakSchema,
        user: z.string(),
        userId: z.string(),
        vacationMode: z.number(),
        weeklyGoal: z.number(),
    }),
    karma: z.number(),
    karmaGraphData: z.array(z.object({
        date: z.string(),
        karmaAvg: z.number(),
    })),
    karmaLastUpdate: z.number(),
    karmaTrend: z.string(),
    karmaUpdateReasons: z.array(KarmaUpdateSchema),
    projectColors: z.record(z.string(), z.string()),
    weekItems: z.array(ItemsWithDateSchema.extend({
        from: z.string(),
        to: z.string(),
    })),
});
export const ColorSchema = z.object({
    /** @deprecated No longer used */
    id: z.number(),
    /** The key of the color (i.e. 'berry_red') */
    key: z.string(),
    /** The display name of the color (i.e. 'Berry Red') */
    displayName: z.string(),
    /** @deprecated Use {@link Color.displayName} instead */
    name: z.string(),
    /** The hex value of the color (i.e. '#b8255f') */
    hexValue: z.string(),
    /**
     * @deprecated Use {@link Color.hexValue} instead
     */
    value: z.string(),
});
/**
 * Flexible object containing event-specific data.
 * Uses z.record to accept any properties for forward compatibility.
 */
export const ActivityEventExtraDataSchema = z.record(z.string(), z.any()).nullable();
/**
 * Activity log event schema. Accepts unknown fields for forward compatibility.
 */
export const ActivityEventSchema = z
    .object({
    objectType: z.string(),
    objectId: z.string(),
    eventType: z.string(),
    eventDate: z.string(),
    id: z
        .union([z.string(), z.number()])
        .transform((val) => { var _a; return (_a = val === null || val === void 0 ? void 0 : val.toString()) !== null && _a !== void 0 ? _a : null; })
        .nullable(),
    parentProjectId: z.string().nullable(),
    parentItemId: z.string().nullable(),
    initiatorId: z.string().nullable(),
    extraData: ActivityEventExtraDataSchema,
})
    .catchall(z.any());
/**
 * Available workspace roles.
 */
export const WORKSPACE_ROLES = ['ADMIN', 'MEMBER', 'GUEST'];
export const WorkspaceRoleSchema = z.enum(WORKSPACE_ROLES);
export const WorkspaceUserSchema = z.object({
    userId: z.string(),
    workspaceId: z.string(),
    userEmail: z.string(),
    fullName: z.string(),
    timezone: z.string(),
    role: WorkspaceRoleSchema,
    imageId: z.string().nullable(),
    isDeleted: z.boolean().default(false),
});
export const WorkspaceInvitationSchema = z.object({
    id: z.string().default('0'),
    inviterId: z.string(),
    userEmail: z.string(),
    workspaceId: z.string(),
    role: WorkspaceRoleSchema,
    isExistingUser: z.boolean(),
});
export const PlanPriceSchema = z.object({
    currency: z.string(),
    amount: z.union([z.number(), z.string()]),
    interval: z.string().optional(),
});
export const FormattedPriceListingSchema = z.object({
    currency: z.string().optional(),
    amount: z.number().optional(),
    interval: z.string().optional(),
    formatted: z.string().optional(),
});
export const WorkspacePlanDetailsSchema = z.object({
    currentMemberCount: z.number(),
    currentPlan: z.enum(['Business', 'Starter']),
    currentPlanStatus: z.enum(['Active', 'Downgraded', 'Cancelled', 'NeverSubscribed']),
    downgradeAt: z.string().nullable(),
    currentActiveProjects: z.number(),
    maximumActiveProjects: z.number(),
    priceList: z.array(FormattedPriceListingSchema),
    workspaceId: z.number(),
    isTrialing: z.boolean(),
    trialEndsAt: z.string().nullable(),
    cancelAtPeriodEnd: z.boolean(),
    hasTrialed: z.boolean(),
    planPrice: PlanPriceSchema.nullable(),
    hasBillingPortal: z.boolean(),
    hasBillingPortalSwitchToAnnual: z.boolean(),
});
export const JoinWorkspaceResultSchema = z.object({
    customSortingApplied: z.boolean(),
    projectSortPreference: z.string(),
    role: WorkspaceRoleSchema,
    userId: z.string(),
    workspaceId: z.string(),
});
/**
 * Available workspace plans.
 */
export const WORKSPACE_PLANS = ['STARTER', 'BUSINESS'];
export const WorkspacePlanSchema = z.enum(WORKSPACE_PLANS);
/**
 * Workspace resource limits.
 */
export const WorkspaceLimitsSchema = z
    .object({
    current: z.record(z.string(), z.any()).nullable(),
    next: z.record(z.string(), z.any()).nullable(),
})
    .catchall(z.any());
/**
 * Workspace properties (flexible object for unknown fields).
 */
export const WorkspacePropertiesSchema = z.record(z.string(), z.unknown());
/**
 * Represents a workspace in Todoist.
 */
export const WorkspaceSchema = z.object({
    id: z.string(),
    name: z.string(),
    plan: WorkspacePlanSchema,
    role: WorkspaceRoleSchema,
    inviteCode: z.string(),
    isLinkSharingEnabled: z.boolean(),
    isGuestAllowed: z.boolean(),
    limits: WorkspaceLimitsSchema,
    logoBig: z.string().nullish(),
    logoMedium: z.string().nullish(),
    logoSmall: z.string().nullish(),
    logoS640: z.string().nullish(),
    createdAt: z.string(),
    creatorId: z.string(),
    properties: WorkspacePropertiesSchema,
});
