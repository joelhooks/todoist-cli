import { TodoistRequestError } from './types/errors.js';
import { isNetworkError, isHttpError } from './types/http.js';
import { v4 as uuidv4 } from 'uuid';
import { API_BASE_URI } from './consts/endpoints.js';
import { camelCaseKeys, snakeCaseKeys } from './utils/case-conversion.js';
import { fetchWithRetry } from './utils/fetch-with-retry.js';
export function paramsSerializer(params) {
    const qs = new URLSearchParams();
    Object.keys(params).forEach((key) => {
        const value = params[key];
        if (value != null) {
            if (Array.isArray(value)) {
                qs.append(key, value.join(','));
            }
            else if (typeof value === 'string' ||
                typeof value === 'number' ||
                typeof value === 'boolean') {
                qs.append(key, String(value));
            }
            else {
                qs.append(key, JSON.stringify(value));
            }
        }
    });
    return qs.toString();
}
const defaultHeaders = {
    'Content-Type': 'application/json',
};
function getAuthHeader(apiKey) {
    return `Bearer ${apiKey}`;
}
function getRetryDelay(retryCount) {
    return retryCount === 1 ? 0 : 500;
}
function getTodoistRequestError(args) {
    const { error, originalStack } = args;
    const requestError = new TodoistRequestError(error.message);
    requestError.stack = originalStack ? originalStack.stack : error.stack;
    if (isHttpError(error)) {
        requestError.httpStatusCode = error.status;
        requestError.responseData = error.data;
    }
    return requestError;
}
function getRequestConfiguration(args) {
    const { baseURL, apiToken, requestId, customHeaders } = args;
    const authHeader = apiToken ? { Authorization: getAuthHeader(apiToken) } : undefined;
    const requestIdHeader = requestId ? { 'X-Request-Id': requestId } : undefined;
    const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, defaultHeaders), authHeader), requestIdHeader), customHeaders);
    return { baseURL, headers };
}
function getHttpClientConfig(args) {
    const { baseURL, apiToken, requestId, customHeaders } = args;
    const configuration = getRequestConfiguration({ baseURL, apiToken, requestId, customHeaders });
    return Object.assign(Object.assign({}, configuration), { timeout: 30000, retry: {
            retries: 3,
            retryCondition: isNetworkError,
            retryDelay: getRetryDelay,
        } });
}
export function isSuccess(response) {
    return response.status >= 200 && response.status < 300;
}
export async function request(args) {
    const { httpMethod, baseUri, relativePath, apiToken, payload, requestId: initialRequestId, hasSyncCommands, customHeaders, customFetch, } = args;
    // Capture original stack for better error reporting
    const originalStack = new Error();
    try {
        let requestId = initialRequestId;
        // Sync api don't allow a request id in the CORS
        if (httpMethod === 'POST' && !requestId && !baseUri.includes(API_BASE_URI)) {
            requestId = uuidv4();
        }
        const config = getHttpClientConfig({ baseURL: baseUri, apiToken, requestId, customHeaders });
        const url = `${baseUri}${relativePath}`;
        const fetchOptions = {
            method: httpMethod,
            headers: config.headers,
            timeout: config.timeout,
        };
        let finalUrl = url;
        switch (httpMethod) {
            case 'GET':
                // For GET requests, add query parameters to URL
                if (payload) {
                    // Convert payload from camelCase to snake_case
                    const convertedPayload = snakeCaseKeys(payload);
                    const queryString = paramsSerializer(convertedPayload);
                    if (queryString) {
                        const separator = url.includes('?') ? '&' : '?';
                        finalUrl = `${url}${separator}${queryString}`;
                    }
                }
                break;
            case 'POST':
            case 'PUT':
            case 'DELETE': {
                // Convert payload from camelCase to snake_case
                // Note: While DELETE with body is uncommon, the Todoist API uses it for some endpoints
                if (payload) {
                    const convertedPayload = snakeCaseKeys(payload);
                    const body = hasSyncCommands
                        ? JSON.stringify(convertedPayload)
                        : JSON.stringify(convertedPayload);
                    fetchOptions.body = body;
                }
                break;
            }
        }
        // Make the request
        const response = await fetchWithRetry({
            url: finalUrl,
            options: fetchOptions,
            retryConfig: config.retry,
            customFetch,
        });
        // Convert snake_case response to camelCase
        const convertedData = camelCaseKeys(response.data);
        return Object.assign(Object.assign({}, response), { data: convertedData });
    }
    catch (error) {
        if (!(error instanceof Error)) {
            throw new Error('An unknown error occurred during the request');
        }
        throw getTodoistRequestError({ error, originalStack });
    }
}
